function asarmmodel = asArm()
% A structure describing the robot kinematics and the inertia
%  parameters according to the model described in "A beginner's guide
%  to 6-D vectors (part 2)" by Roy Featherstone.
%
%  This file has been automatically generated by the robotics code
%  generator developed by Marco Frigerio at the Italian Institute of
%  Technology.


asarmmodel.robotname = 'asArm';

asarmmodel.NB = 7 + 5;
asarmmodel.parent = zeros(1, 6 + 5);

asarmmodel.jtype(1:6) = {'Px', 'Py', 'Pz', 'Rx', 'Ry', 'Rz'};
asarmmodel.parent(1:6) = [0 1 2 3 4 5];

for i = 1:6
    % For the 'I' field, a loop until i=5 would be enough
    asarmmodel.I{i} = mcI( 0, [0,0,0], zeros(3) );
    % 'Xtree' instead must be initialized up to i=6
    asarmmodel.Xtree{i} = eye(6);
end

asarmmodel.parent(1+6) = 6;
asarmmodel.parent(2+6) = 1+6;
asarmmodel.parent(3+6) = 2+6;
asarmmodel.parent(4+6) = 3+6;
asarmmodel.parent(5+6) = 4+6;
asarmmodel.parent(6+6) = 5+6;

asarmmodel.jtype{1+6} =  'Rz' ;
asarmmodel.jtype{2+6} =  'Rz' ;
asarmmodel.jtype{3+6} =  'Rz' ;
asarmmodel.jtype{4+6} =  'Rz' ;
asarmmodel.jtype{5+6} =  'Rz' ;
asarmmodel.jtype{6+6} =  'Rz' ;

asarmmodel.Xtree{1+6} = rotz(0.0 ) * ...
roty(0.0 ) * ...
rotx(0.0 ) * ...
xlt([0.175 0.0 0.214]);
;
asarmmodel.Xtree{2+6} = rotz(0.0 ) * ...
roty(0.0 ) * ...
rotx(-1.5708 ) * ...
xlt([0.0 0.0 0.0]);
;
asarmmodel.Xtree{3+6} = rotz(0.0 ) * ...
roty(0.0 ) * ...
rotx(0.0 ) * ...
xlt([0.0535 -0.2845 0.0]);
;
asarmmodel.Xtree{4+6} = rotz(0.0 ) * ...
roty(0.0 ) * ...
rotx(-1.5708004 ) * ...
xlt([0.0775 0.3425 -0.0]);
;
asarmmodel.Xtree{5+6} = rotz(0.0 ) * ...
roty(0.0 ) * ...
rotx(1.5707996 ) * ...
xlt([0.0 0.0 0.0]);
;
asarmmodel.Xtree{6+6} = rotz(0.0 ) * ...
roty(0.0 ) * ...
rotx(-1.5708004 ) * ...
xlt([0.076 0.097 -0.0]);
;


tmpI   = [[  0.008853708,	-(3.5E-6),	-(0.017956674)];
 [-(3.5E-6),	  0.0915342 ,	-(-1.67E-6)];
 [-(0.017956674),	-(-1.67E-6),	  0.084906496]];
tmpC   = skew([0.175; 0.0; 0.03803]);
tmpMass= 2.7;
asarmmodel.I{6} = [tmpI, tmpMass*tmpC; tmpMass*tmpC', eye(3)*tmpMass];

tmpI   = [[  0.0073428256,	-(-1.272444E-4),	-(5.5907403E-5)];
 [-(-1.272444E-4),	  0.0052897725 ,	-(-0.0015675207)];
 [-(5.5907403E-5),	-(-0.0015675207),	  0.0046896925]];
tmpC   = skew([-0.002; 0.02692; -0.01332]);
tmpMass= 2.16;
asarmmodel.I{7} = [tmpI, tmpMass*tmpC; tmpMass*tmpC', eye(3)*tmpMass];


tmpI   = [[  0.105124444,	-(-0.008613624),	-(0.0027224403)];
 [-(-0.008613624),	  0.008948017 ,	-(-0.016962022)];
 [-(0.0027224403),	-(-0.016962022),	  0.10430682]];
tmpC   = skew([0.03531; -0.21398; 0.03386]);
tmpMass= 1.71;
asarmmodel.I{8} = [tmpI, tmpMass*tmpC; tmpMass*tmpC', eye(3)*tmpMass];


tmpI   = [[  0.021654077,	-(0.008669333),	-(0.0022883206)];
 [-(0.008669333),	  0.0099000055 ,	-(0.003859303)];
 [-(0.0022883206),	-(0.003859303),	  0.027372088]];
tmpC   = skew([0.06781; 0.10749; 0.01457]);
tmpMass= 1.384;
asarmmodel.I{9} = [tmpI, tmpMass*tmpC; tmpMass*tmpC', eye(3)*tmpMass];


tmpI   = [[  0.0058518867,	-(-5.631638E-5),	-(-7.797278E-6)];
 [-(-5.631638E-5),	  0.004725969 ,	-(-0.0011829191)];
 [-(-7.797278E-6),	-(-0.0011829191),	  0.0018442962]];
tmpC   = skew([-2.1E-4; 0.025779976; -0.025379976]);
tmpMass= 1.115;
asarmmodel.I{10} = [tmpI, tmpMass*tmpC; tmpMass*tmpC', eye(3)*tmpMass];


tmpI   = [[  0.0016447763,	-(7.4014865E-4),	-(7.6726405E-4)];
 [-(7.4014865E-4),	  0.0060817497 ,	-(2.4680307E-4)];
 [-(7.6726405E-4),	-(2.4680307E-4),	  0.006847581]];
tmpC   = skew([0.05428; 0.01781; 0.00543]);
tmpMass= 1.275;
asarmmodel.I{11} = [tmpI, tmpMass*tmpC; tmpMass*tmpC', eye(3)*tmpMass];


tmpI   = [[  0.0108265085,	-(0.0),	-(0.0)];
 [-(0.0),	  0.010829282 ,	-(-6.6778057E-7)];
 [-(0.0),	-(-6.6778057E-7),	  0.0013922598]];
tmpC   = skew([0.0; 6.048977E-5; 0.07606634]);
tmpMass= 1.1596;
asarmmodel.I{12} = [tmpI, tmpMass*tmpC; tmpMass*tmpC', eye(3)*tmpMass];

